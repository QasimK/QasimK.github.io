---
layout: remark-talk
title: Automating Code Review As Much As Possible
where: PyCon UK 2019
date: 2019-09-07
---

<style>
  .remark-slide-content h1 {
    font-size: 53px;
  }
</style>

# Automating Code Review As Much As Possible

### [QasimK.io](https://QasimK.io) @ PyCon UK 2019

```python
def test_continuous_integration():
    subprocess.call(['git', 'commit', '--no-verify'])
    subprocess.call(['git', 'push', '-fu'])
    if input() == 'Hey, why are the tests broken - again?':
        print('requests.get("http://codingexcuse.com")')
```

.footnote.smaller[.red[*] Side-effects may include irritated colleagues and performance improvement plans]

---

Interactive?
  Who uses Pyflakes?

# Overview

This talk will cover:

1. What is involved in Code Review?
2. When is it appropriate?
3. What is the potential for automation?
4. What tools are available in Python?
5. How can these integrate into the workflow?

---

# What do we gain from Code Review?

* Catching bugs
* Enforcing security
* Conforming to codebase style guidelines
* Making the code easier to read, maintain and extend
* Sharing knowledge about the project
* An opportunity to learn

## Why do we want to automate this?

We will save time and mental energy for more important matters.

Minimise the time spent on code reviews.
Stops nitpicking; reduces opinions.

We want to get as much done before it gets to another developer.

---

# How can we catch bugs?

* Pyflakes is fast.
* Flake8 = Pyflakes + pycodestyle + McCabe
* Pylint is comprehensive, but an order of magnitude slower.
* Type-checking. I'm not sure whether the community accepts type hints. But it's saved me. It. Saved. My.
* McCabe can be used to set a hard limit on the complexity of code.

I don't think McCabe is useful. You generally *see* complexity.

???

It isn't necessarily useful to set a very low limit for McCabe.

You can generally tell when something is too complicated.

---

# How can we enforce style?

* pycodestyle [PEP8]
* pydocstyle [PEP257 - docstrings]
* Import ordering - isort

I would talk about tools like flake8 that check PEP8 and then output errors.

But I'm not. You want Black. No you don't get an opinion. That's what it is.

You want isort because this too can automatically re-write your code.

* gitattribute
* editor-on-save - editorconfig

* Spell-checking would be nice but I don't see that going well with any team.

???

Raymond Hettinger did a talk at PyCon 2015 called "Beyond PEP 8", which demonstrates why you might want a tool like this.

It was funny and enlightening, and I strongly recommend watching it.
In fact, consider watching it *right now*!

This is a case where giving up power, gives you more power.

The style of the code is not unimportant. I think it is very important. But, ultimately, there *are* more important things.

Black did actually compromise in two areas. You can now select the line length and whether you want to normalise strings into double quotes. However, this massively expanded the adoption of this tool into existing codebases.

The holy duality of black and isort will resolve everything except docstrings.

docformatter might be helpful here.

---

# Black

In fact, let me show how to do a one-off fix:

*

Use git hyper-log to not destroy the git history.

---

## Can we check security?

We can make an *attempt* at it.

Detecting dangerous code patterns.

* Bandit

B410  import_lxml

???

It isn't completely useless.

You may not know everything

Indirectly:

* Outdated versions - tools. CVE checking security libraries.

---

# Is there something more comprehensive?

* Prospector?

---

# How do you introduce new tools?

The scrolling screen of death...

* Check only *new* code
* Divide up existing code by ignoring particular warnings and files.
* `git diff upstream/master "./**/*.py" | flake8 --diff --isolated`

---

## Workflow integration

The more seamless a tool is integrated, the less resistance there will be.

The integration scale:

1. Running the checks during CI after creating the Pull Request
  a. For example, CodeFresh, Shippable, or Jenkins just failing the build.
2. Manually running the tool `pylint` or `make lint` locally
3. The tools outputting comments on the Pull Request
  a. For example, Codacy.
4. Running them as a pre-commit hook.
5. Integrated into the IDE.
   Autopick, e.g. IntelliJ picks up eslint.

Strong IDE integration means the least back-and-forth.

For a large project CI is essential, but if you can catch things with your IDE it is much faster.

> The faster the tool runs, the more often people will run it.

???

Yes, manually running the tool is less integrated than comments outputting

IDE integration can be so unobtrusive that you do not even realise you were running linters.

---

# When should we not use these tools?

I encourage you to not set up any tools on one-off scripts and non-collaborative projects. It is simply a waste of time!

(Implementing a tool earlier on is much easier than later.)

### There are other tools too!

* shellcheck for checking shell scripts
* hadolint for checking Dockerfiles
* QA - Heroku's preview servers on PRs

And so on...

???

Larry Hasting's talk at PyCon 2018 "Solve Your Problems With Sloppy Python"

---

# Conclusion

* Use Black for every project.
* A plethora of tools are available @ <https://github.com/PyCQA>

## My biased view

* Configure your IDE or text editor with linting tools to give you immediate-but-discreet feedback. Sublime phantoms are annoying, but look at this beautiful faded out unused variable.
* Always use `black` and `isort` and never think about the style of your code again. Integrate them with your IDE to execute on save.
* Use Bandit.
* Depending on how much time you want to invest:
  * flake8
  * pylint
* Don't bother with McCabe
* Code test coverage could be a good way to view the "health" of your project, but it is not useful day-to-day.

---

### Linting

1. PEP8 style - [flake8] includes [pyflakes], [pycodestyle] and [mccabe]
2. PEP257 Docstrings [pydocstyle]
3. Unused Code - [vulture]
4. Import Order [isort] (perhaps [flake8-isort])
5. pep8-naming
6. Spell checking (pylint spelling)

### Testing

1. Tox (combine all tools into one line).
2. Parallel testing.
3. Unit-tests vs Integration Tests vs Smoke Tests.

### Security

1. Dodgy (Just dodgy things).
2. Safety (Dependencies checking) (NB: Pipenv).
3. Bandit.

### Code Review

1. Pylint (Static code analysis) [pylint-django]
2. mypy (Typing) (flake8-mypy)
3. McCabe's complexity (mccabe/radon)

### Documentation

1. Build developer documentation automatically.
2. Host documentation.



---

class: center, middle, inverse

# Questions?

???

Backup questions - if no one asks any questions:
  * Sometimes its wondered...

Additional / Alternative Resources / References:

* https://realpython.com/python-code-quality/
