---
layout: remark-talk
title: Automating Code Review As Much As Possible
where: PyCon UK 2019
date: 2019-09-07
---

<style>
  .remark-slide-content h1 {
    font-size: 53px;
  }
</style>

<!--
Interactive?
  Who uses Pyflakes?
-->


# Automating Code Review As Much As Possible

.subtitle[
While the best code is no code at all, we do need to deal with the rest of it.
]

### [QasimK.io](https://QasimK.io) @ PyCon UK 2019

```python
# Automation 101*
def test_continuous_integration_pipeline_is_working():
    message = requests.get('http://whatthecommit.com/index.txt').text
    subprocess.call([
        'git', 'commit', '--all', '--no-verify', '--author=Bot<>', '-m', message
    ])
    subprocess.call(['git', 'push', '-fu'])

    if input() == 'Does anyone know why master is broken, AGAIN?':
        print('Nope!')
```

.footnote.smaller[.red[*] Side-effects may include irritated colleagues and performance improvement plans.]

???

* The best code is no code at all.
* This naturally means the rest of your codebase, which is about - all of it - is *not* the best code.
* Code review lets us deal with this situation.
* And I believe we have the same principle for code review - the best code reviewing is when *you're* not doing it.
* So naturally, this talk is about how to most effectively be lazy.

---

# Overview

* What is involved in code review and what can we automate?

* What tools are available for Python?

* How can we integrate these into our workflows?

???

-> Talk over slide.
(1 - We will briefly cover what we trying to gain from code review.)
(2 - We will look at some of the tools available for Python.)

--

.center[
<br>
<br>
When, what and how should we **not** automate?
]

???

We'll do this while paying attention to when, what and how should we **not** be automating?

---

# What do we gain from Code Review?

* Catch bugs
* Enforce security
* Code that is easier to read, maintain, and extend
* An opportunity to mentor and learn

???

Let's briefly cover what we are actually trying to automate.

We want to be able to catch bugs, reduce security vulnerabilities, make the code more maintainable, and teach and learn.

All of these aspects, save the last, can be partially automated.

--

## What do we gain from automating these things?

* Reduction in the total time everyone spends reviewing code.
* Ability to review your own code before asking someone else.
* Less nitpicking and conflicts of opinion.
* Ability to focus on what matters the most.

???

It is not a joke that at one point I was spending more time reviewing code than actually coding.

You are free to focus on the use of third-party libraries, architectural issues, and other higher-level concerns that current tooling cannot consider intelligently.

--

## What can we lose from automating these things?

* Time spent setting up the tools
* Time spent changing code that does not actually improve things

???

Some tools require much more set up and careful introduction to the codebase than others.

When a tool is telling you that you are doing something wrong, when you and I would say this is perfectly fine in the context it is in. This usually means ignoring the warning, silencing the error, or altering the tool configuration.

Improperly configured tools, or those with excessive output can also be annoying. This could lead to them being ignored or hated.

We need to make sure that we use the right tools for the situation, properly configured and strongly integrated within our workflows to gain the benefits on offer.

---

class: center, middle, inverse

# The Right Tools for the Job

???

Let's start off by looking at the tools available for Python.

What should we consider using, and what should we consider avoiding.

---

# How can we check code style?

???

At the most basic, and least important level is the formatting of the code.

I think this is important, but it less important than real bugs and security concerns.

I am not going to talk about why consistency of code style is important, but instead jump into how to do it.

As recently as last year I would have talked about tools like pycodestyle, flake8 or pylint that check against PEP8 and then output errors. These tools are literally evil.

Do. Not. Use. Them. To check your code formatting.

They are literally evil because of:

1. The massive back and forth they cause, and
2. Their configurability

What you want to use is black, isort and docformatter.

--

## black + isort + docformatter

Once upon a time someone implemented the three heaven-sent tools, and everyone lived happily ever after. The End.

???

**This is the holy trinity of code styling!**

You have to be careful with docformatter - it really can mess up your docstrings at first.

Raymond Hettinger did a talk at PyCon 2015 called "Beyond PEP 8", which demonstrates why you might want a tool like this.

It was funny and enlightening, and I strongly recommend watching it.
In fact, consider watching it *right now*!

This is a case where giving up power, gives you more power.

The style of the code is not unimportant. I think it is very important. But, ultimately, there *are* more important things.

Black did actually compromise in two areas. You can now select the line length and whether you want to normalise strings into double quotes. However, this massively expanded the adoption of this tool into existing codebases.

The holy duality of black and isort will resolve everything except docstrings.

docformatter might be helpful here.

The only question remains is how do you inflict it on your existing, massive codebase with thousands of developers.

--

### How?

* Nuke your entire codebase in one go:
  <https://engineering.depop.com/implementing-python-black-on-a-legacy-codebase-35b37f10ce18>

* Run it on every save and commit

???

For this I would redirect you to this article by one of my former colleagues where they applied black to an existing, legacy codebase.

Don't worry - the slides are already on my website.

We'll talk about running it on save and commit later when we go into the workflow.

---

# How can we check code style?

## What's left?

* Other files - .editorconfig - <https://editorconfig.org/>

* Spell checking

  ![](../../2019-09-13-spell-checking-ide.png)

???

EditorConfig comes integrated with many IDEs like PyCharm, and is available as a plugin for others like Atom, Sublime Text, VS Code, and Vim.

Spell checking would be nice but I don't see that going down well with any team.

I think there would be far too many false positives for it to be worthwhile.

---

# How can we catch bugs?

* Pyflakes is fast.
* Flake8 = Pyflakes + pycodestyle + McCabe
* Pylint is comprehensive, but an order of magnitude slower.
* Type-checking. I'm not sure whether the community accepts type hints. But it's saved me. It. Saved. My.
* McCabe can be used to set a hard limit on the complexity of code.

I don't think McCabe is useful. You generally *see* complexity.

???

Spot: Code Smells - dangerous code patterns, code with potentially unintended results.

It isn't necessarily useful to set a very low limit for McCabe.

You can generally tell when something is too complicated.

Typing: Yes, I know you want a number, but sometimes I just want to give you a duck!!!! Deal with it!!

Pylint: Probably too much. It covers code style, conventions, errors, duplicated code.

---

# How can we check security?

???

We can certainly try, and it is better than nothing.

--

## Bandit

Finding common security mistakes.

--

```
import lxml
```

--

```console
$ bandit -r .
Issue: [B410:blacklist] Using lxml to parse untrusted XML data is known to be
vulnerable to XML attacks. Replace lxml with the equivalent defusedxml package.
   Severity: Low   Confidence: High
   Location: ./main.py:1
   More Info: bandit.readthedocs.io/en/latest/blacklists/blacklist_imports.html
#b410-import-lxml
1       import lxml
```

---

# How can we check security?

## Bandit

```
import random
random.random()
```

--

```
>> Issue: [B311:blacklist] Standard pseudo-random generators are not suitable for security/cryptographic purposes.
   Severity: Low   Confidence: High
   Location: ./main.py:9
   More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html
   #b311-random
1       import random
2       random.random()
```

???

It isn't completely useless.

You may not know everything

Indirectly:

* Outdated versions - tools. CVE checking security libraries.

* Safety (pipenv)

---

# Can we check security?

## Dependencies

???

Dependencies can be a bit of a minefield.

I recommend keeping dependencies up-to-date. Update them when you use them! Even for no reason!

--

With `safety` or `pipenv`:

```console
$ pipenv check
Checking PEP 508 requirements…
Passed!
Checking installed package safety…
37261: django <2.2.3,>2.2 resolved (2.2.1 installed)!
[...] An HTTP request is not redirected to HTTPS [...]
```

???

This is incredibly easy to use, with essentially no false positives. It's a no-brainer.

You can even configure your CI pipeline to fail outright.

--

With GitHub's `dependabot` Pull Requests:

![](../../2019-09-13-github-dependabot.png)

???

Not can this search for out-of-date dependencies, in particular security issues, this creates such an easy to use pull request. It does the work for you. The only problem is, you can say no.

---

# What have we not covered?

* More comprehensive all-in-one tools
* Paid services
* Introducing your own automation

???

I have not talked about more comprehensive all-in-one tools like Prospector, or Sonarr

I have not really covered any paid tools or services like Codacy, Landscape.io, or SonarQube

You can, of course, introduce your own automated checks.

Do you want to check that all the upgrade and downgrade migrations actually work?

Do you want to verify that someone has not forgotten to commit a migration?

---

# Workflow Integration

---

# How do you introduce new tools?

The scrolling screen of death...

* Check only *new* code
* Divide up existing code by ignoring particular warnings and files.
* `git diff upstream/master "./**/*.py" | flake8 --diff --isolated`

---

# Workflow Integration

The more seamless a tool is integrated, the less resistance there will be.

The integration scale:

1. Running the checks during CI after creating the Pull Request
  a. For example, CodeFresh, Shippable, or Jenkins just failing the build.
2. Manually running the tool `pylint` or `make lint` locally
3. The tools outputting comments on the Pull Request
  a. For example, Codacy.
4. Running them as a pre-commit hook.
5. Integrated into the IDE.
   Autopick, e.g. IntelliJ picks up eslint.

Strong IDE integration means the least back-and-forth.

For a large project CI is essential, but if you can catch things with your IDE it is much faster.

> The faster the tool runs, the more often people will run it.

???

HOW do we want to automate code review?

Yes, manually running the tool is less integrated than comments outputting

IDE integration can be so unobtrusive that you do not even realise you were running linters.

---

# When should we not use these tools?

I encourage you to not set up any tools on one-off scripts and non-collaborative projects. It is simply a waste of time!

(Implementing a tool earlier on is much easier than later.)

### There are other tools too!

* shellcheck for checking shell scripts
* hadolint for checking Dockerfiles
* QA - Heroku's preview servers on PRs

And so on...

???

Larry Hasting's talk at PyCon 2018 "Solve Your Problems With Sloppy Python"

---

# Conclusion

My order of priority:

1. Add Black and isort on save, on commit, & in CI.
2. Configure your text editor with pyflakes for every project.
3. Add Bandit in CI.
4. Add Safety in CI.
5.

In general, if there's something you're looking out for in code review - consider automating it!

* Do downgrade migrations work?
* Are requirements pinned?

* Use Black for every project.
* A plethora of tools are available @ <https://github.com/PyCQA>

## My biased view

* Configure your IDE or text editor with linting tools to give you immediate-but-discreet feedback. Sublime phantoms are annoying, but look at this beautiful faded out unused variable.
* Always use `black` and `isort` and never think about the style of your code again. Integrate them with your IDE to execute on save.
* Use Bandit.
* Depending on how much time you want to invest:
  * flake8
  * pylint
* Don't bother with McCabe
* Code test coverage could be a good way to view the "health" of your project, but it is not useful day-to-day.

---

class: center, middle, inverse

# Questions?

???

Backup questions - if no one asks any questions:
  * Sometimes its wondered...

Additional / Alternative Resources / References:

* https://realpython.com/python-code-quality/


